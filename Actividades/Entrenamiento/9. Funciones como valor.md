# Funciones cómo valor

Hasta ahora hemos visto una clara separación entre **valores** (campos) y **funciones** (métodos), ¿pero qué ocurre cuando empezamos a tratar las funciones como valores?

## Linq

### Ejecución de Consultas

De hecho, ya lo hemos estado haciendo con Linq. No solo porque hayamos usado lambdas, sino por cómo se ejecuta Linq internamente. Para ver a lo que me refiero, copia este código y ejecútalo. La ejecución debería detenerse en `Debugger.Break()`

```cs
/*
Necesitais tener en el archivo:
using System.Diagnostics;
*/
int[] numbers = [1, 2, 3, 4];
var query = numbers.Select(num => {
    Console.WriteLine("Number: " + num);
    return num;
});
Debugger.Break(); //Breakpoint pero en código
```

En teoría el código del `Select` es simple: devuelve el número tal cual, pero antes escríbelo por pantalla. ¿Porqué no aparece nada en la consola entonces?

Si lo habeis hecho todo bien, estareis ahora parados en el breakpoint. Seguid las siguientes instrucciones:

- Id al **depurador**
- En la sección de variables debería haber una subsección llamada **locals**
- Dentro de **locals** está la variable **query** de tipo `IEnumerable`.
- Expandid su contenido apretando **la "flecha"** `❯` que hay a la izquierda de su nombre.
  - Vereis que su contenido no se parece nada el del array **numbers**. Es normal.
- Expandid ahora la parte en la que pone **Vista de resultados** (dentro de la variable query).
- Mirad lo que ha ocurrido en la consola.

¿Cómo es posible eso? La ejecución estaba completamente parada y no ha cambiado nada del código. ¿Qué ha desencadenado que se escriba lo que queríamos cuando no se mostraba antes?

Muy simple: le has pedido que te muestre los resultados. `Select` en realidad no significa "haz esta operación sobre este conjunto de valores" sino "crea una especie de consulta que me permita obtener valores siguiendo este proceso" y lo mismo se aplica a casi todas las funciones de  `Linq`.

A efectos prácticos, eso significa que los cálculos que tu le pides hacer en el select **no se ejecutan hasta que los utilizas**. Ejecuta el siguiente ejemplo para verlo más claro:

```cs
int[] numbers = [1, 2, 3, 4];
var query = numbers.Select(num => {
    Console.WriteLine("Number: " + num);
    return num;
});
query.First();
```

Le estás pidiendo solo el primer valor, así que solo calcula el primer valor. Es tan simple como eso.

### Cadenas de consultas

*"Vale profe, pero pensaba que este tema iba de usar funciones como si fueran variables, no de consultas."* Claro, lo que digo es que ya lo estais haciendo, que las consultas de `Linq` en el fondo son funciones encadenadas una detrás de otra que podeis llamar a voluntad.

Mirad lo que ocurre al ejecutar esto:

```cs
int[] numbers = [1, 2, 3, 4];
var query = numbers.Select(num => {
    Console.WriteLine("Number: " + num);
    return num;
});

query.Count(); 
query.Take(2).ToArray(); 
query.Skip(2).First();
```

No es simplemente que la query evite calcular las cosas hasta que las necesita, es que la query es una secuencia de operaciones que no almacena los valores en ningún momento.

Secuencias que, de hecho, podemos **reutilizar** para **construir** múltiples otras secuencias. Probad: (recomiendo ir paso a paso con el **depurador**)

```cs
int[] numbers = [0, 1, 2, 3, 4];
IEnumerable<int> minus = numbers.Select(num => {
    int result = 10 - num;
    Console.WriteLine($"10 - {num} = {result}");
    return result;
});

IEnumerable<string> stringify = minus.Select(num => {
    Console.WriteLine($"stringify {num}");
    return num.ToString();
});

Console.WriteLine("Calculating Max");
minus.Max(); //Obliga a calcular para tener el máximo

Console.WriteLine("Stringify in reverse");
foreach (var reversed in stringify.Reverse()) {
    //Obliga a calcular los valores para poder iterar
}
```


## Lambdas

Ahora que hemos visto lo que podemos hacer en Linq ya podemos empezar a imaginarnos las utilidades de poder tratar secuencias de acciones como si fueran valores y a entender el verdadero poder de las lambdas.

Sin embargo, hay un problema: las funciones, anónimas o no, no son de tipo `IEnumerable`. No podemos trabajar con ellas exactamente igual. Necesitamos usar "delegados".

### Delegados

No quiero entrar en demasiado detalle con los delegados (o delegates) aún porque son muy complejos. Sin embargo, su idea es muy simple: son una referencia a una función. Igual que antes trabajabamos con referencias a instancias de una clase, ahora podemos hacer lo mismo pero con funciones.

```cs
//Así se declara un delegado (recomiendo usar "var" por simplicidad)
var helloWorld = () => Console.WriteLine("HolaMundo!");
//Así se "llama" o "invoca" un delegado
helloWorld();
```

Pero es que usar delegados no esta limitado a funciones anónimas, también podemos hacer esto:

```cs
//Action es un subtipo de delegado
Action<string> speak = Console.WriteLine;
speak("HolaMundo!");
//Nos dice si ambas son la misma función
speak((speak == Console.WriteLine).ToString());
```

Y las podemos combinar para crear otras:

```cs
Action<string> speak = Console.WriteLine;
//Igual que speak pero convierte primero en mayúsculas
Action<string> shout = (input) => speak(input.ToUpper());
speak("HolaMundo!");
shout("HolaMundo!");
```

De hecho, podemos hacer funciones que generen otras funciones.

```cs
//Saludador es una lambda que devuelve otra lambda
var saludador = (string cosa) => () => Console.WriteLine($"Hola {cosa}!");
//Crear saludadores
var holaMundo = saludador("Mundo");
var holaAmigo = saludador("Amigo");
var holaGlobal = saludador("a todos");
//Ejecutar saludadores
holaGlobal();
holaMundo();
holaAmigo();
```

### Usos

Vale, todo esto está muy bien, ¿pero para qué queremos esto? ¿De qué sirve además de para hacer virguerías con el código?

Recordais lo que hicimos con `PowerSystem` en el [entrenamiento 4](4.%20Herencias%20Conflictivas.md)? Tener la funcionalidad del sistema de propulsión como una valor (una referencia a una instancia de `PowerSystem`) en vez de como una parte fija de la clase nos daba una flexibilidad que resultaba imposible tener usando herencia. Esto es igual.

De la misma forma que sobreescribimos métodos virtuales, podemos simplemente hacer que las clases hijas tengan funciones distintas en sus delegados. Ejemplo:

```cs
public class Parent {
    public Action HacerAlgo = () => { }; //No hace nada
}

public class Counter:Parent {
    private int count = 0;
    public Counter() {
        HacerAlgo = () => {
            count++;
            Console.WriteLine(count);
        };
    }
    
}
```

Pero lo mejor es que no hace falta ni hacer subclases. Es un valor, igual que cada instancia puede tener un valor de `string name` distinto, pueden tener un valor de delegado distinto.

```cs
public class Hacedor {
    public Action HacerAlgo;

    public Hacedor(Action? action= null) {
        HacerAlgo = action ?? (() => { }); //No hace nada si action es null
    }
}
```

Y ahora en el código podemos simplemente hacer:

```cs
var gandul = new Hacedor();
int count = 0; //Count para la lambda
var contador = new Hacedor(() => {
    count++;
    Console.WriteLine(count);
});
contador.HacerAlgo();//1
contador.HacerAlgo();//2
gandul.HacerAlgo();//Nada
```


### Ámbitos y variables locales

> [!warning]
> Esta parte será expandida en el futuro

<!-- TODO: elaborar -->